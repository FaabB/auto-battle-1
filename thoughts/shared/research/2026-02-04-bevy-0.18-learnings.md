# Bevy 0.18 Development Learnings

## Overview

Learnings from setting up a Bevy 0.18 project with testing infrastructure.

## Dynamic Linking Not Yet Available

**Issue**: `make dev` (with `--features bevy/dynamic_linking`) fails because `bevy_dylib` 0.18.0 hasn't been published to crates.io yet.

```
error: failed to select a version for the requirement `bevy_dylib = "^0.18.0"`
candidate versions found which didn't match: 0.18.0-rc.2, 0.18.0-rc.1, 0.17.3, ...
```

**Workaround**: Use `cargo run` without dynamic linking until the crate is published. Build times are still reasonable with LLD linker configured.

**Status**: Check crates.io periodically for `bevy_dylib` 0.18.0 release.

## Testing with MinimalPlugins Requires StatesPlugin

**Issue**: Using `MinimalPlugins` for integration tests doesn't include state management.

```rust
// This panics:
let mut app = App::new();
app.add_plugins(MinimalPlugins);
app.add_plugins(GamePlugin);  // GamePlugin calls init_state::<GameState>()
// Error: "The `StateTransition` schedule is missing"
```

**Solution**: Explicitly add `StatesPlugin`:

```rust
use bevy::state::app::StatesPlugin;

fn create_game_app() -> App {
    let mut app = App::new();
    app.add_plugins(MinimalPlugins);
    app.add_plugins(StatesPlugin);  // Required for state management
    app.add_plugins(InputPlugin);
    app.add_plugins(GamePlugin);
    app
}
```

## FreelyMutableState Trait Bound for Generic State Functions

**Issue**: Generic functions that call `init_state::<S>()` need more than just `States` bound.

```rust
// This fails to compile:
pub fn create_test_app_with_state<S: States + Default>() -> App {
    let mut app = create_test_app();
    app.init_state::<S>();  // Error: FreelyMutableState not satisfied
    app
}
```

**Solution**: Add `FreelyMutableState` bound:

```rust
use bevy::state::state::FreelyMutableState;

pub fn create_test_app_with_state<S: FreelyMutableState + Default>() -> App {
    let mut app = create_test_app();
    app.init_state::<S>();
    app
}
```

Note: `FreelyMutableState` is a subtrait that `#[derive(States)]` implements, but generic bounds need it explicitly.

## Rust Test Directory Structure

**Issue**: `tests/integration.rs` doesn't automatically find modules in `tests/integration/` directory.

```rust
// tests/integration.rs
mod state_transitions;  // Error: can't find module
```

**Solution**: Use path attribute:

```rust
// tests/integration.rs
#[path = "integration/state_transitions.rs"]
mod state_transitions;  // Works
```

**Also**: Cannot have both `tests/integration.rs` AND `tests/integration/mod.rs` - Rust sees this as ambiguous module definition.

## Previous Handoff Learnings (Still Valid)

From earlier session - still applicable:

1. **`despawn()` vs `despawn_recursive()`**: With just `features = ["2d"]`, use `despawn()`. The `despawn_recursive()` method requires hierarchy features.

2. **WindowResolution uses integers**: `(1920, 1080).into()` not `(1920.0, 1080.0).into()`.

3. **Camera2d is simple marker**: Don't bundle with `OrthographicProjection` - just spawn `Camera2d` alone.
